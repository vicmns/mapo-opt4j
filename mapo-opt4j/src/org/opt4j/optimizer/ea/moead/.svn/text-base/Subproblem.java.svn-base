package org.opt4j.optimizer.ea.moead;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Vector;

import javax.inject.Inject;

import org.opt4j.common.random.Rand;
import org.opt4j.core.Individual;
import org.opt4j.core.IndividualFactory;
import org.opt4j.core.Objective;
import org.opt4j.viewer.ObjectivesMonitor;
import org.opt4j.viewer.ObjectivesMonitor.ObjectivesListener;

/**
 * A subproblem generated by decomposition.
 * 
 * @author reimann
 * 
 */
public class Subproblem implements ObjectivesListener {
	private Individual best;
	private Individual child;
	private final Vector<Double> weightVector = new Vector<Double>();
	private final Rand random;
	private int objectivesM = -1;
	private final List<Subproblem> neighbors = new ArrayList<Subproblem>();

	/**
	 * Creates a new {@link Subproblem}.
	 * 
	 * @param objectivesMonitor
	 * @param individualFactory
	 * @param random
	 */
	@Inject
	public Subproblem(ObjectivesMonitor objectivesMonitor, IndividualFactory individualFactory, Rand random) {
		this.random = random;
		best = individualFactory.create();
		objectivesMonitor.addListener(this);
	}

	/**
	 * Initializes the weight vector of this {@link Subproblem} according to the
	 * number of objectives {@code m}.
	 */
	public void initWeightVector() {
		assert objectivesM >= 0;
		double sum = 0;
		for (int j = 0; j < objectivesM; j++) {
			weightVector.add(random.nextDouble());
			sum += weightVector.get(j);
		}
		for (int j = 0; j < objectivesM; j++) {
			weightVector.set(j, weightVector.get(j) / sum);
		}
	}

	public Individual getBest() {
		return best;
	}

	public void setBest(Individual best) {
		this.best = best;
	}

	/**
	 * Returns the weight vector.
	 * 
	 * @return the weight vector
	 */
	public Vector<Double> getScalar() {
		return weightVector;
	}

	/**
	 * Returns the neighboring {@link Subproblem}s of this {@link Subproblem}.
	 * 
	 * @return neighboring subproblems
	 */
	public List<Subproblem> getNeighbors() {
		return neighbors;
	}

	/**
	 * Adds a neighboring {@link Subproblem}.
	 * 
	 * @param neighbor
	 */
	public void addNeighbor(Subproblem neighbor) {
		neighbors.add(neighbor);
	}

	public void setChild(Individual child) {
		this.child = child;
	}

	public Individual getChild() {
		return child;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.opt4j.viewer.ObjectivesMonitor.ObjectivesListener#objectives(java
	 * .util.Collection)
	 */
	@Override
	public void objectives(Collection<Objective> objectives) {
		this.objectivesM = objectives.size();
	}
}